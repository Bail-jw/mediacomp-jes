%%%% NEW CHAPTER %%%%%

\chapter{Modifying Pixels in a Range}

\begin{exercises}

\begin{ex}

\begin{itemize}

\item Turn just the teeth purple.
\begin{example}
# suppose pic is the picture of the person, tx and ty are the top
# left corner of the mouth and w and h are the width and height of
# the mouth region
def purpleTeeth(pic, tx, ty, w, h):
  for x in range(w):
    for y in range(h):
      p = getPixel(pic, tx + x, ty + y)
      if (distance(getColor(p), white) < 40): #you can modify this number
based on the brightness of the photo
        setGreen(p, 0) #if the pixel was pretty white to begin with, that
means eliminating green will give it a purple color
\end{example}

\item Turn the eyes red.
\begin{example}
# suppose pic is the picture of the person, tx and ty are the center
# of the pupil and r is the radius of the eye
def makeEyeRed(pic, tx, ty, r):
  for x in range(tx - r, tx + r):
    for y in range(ty - r, ty + r):
      if pow(tx - x, 2) + pow(ty - y, 2) r r:
        p = getPixel(pic, x, y)
        setColor(p, red)
\end{example}

\item Turn the hair orange.
\begin{example}
# suppose pic is the picture of the person, tx and ty are the
# coordinates of the top left corner of their hair region and
# w, h are the width and height of their hair region and color
# is close to the color of their hair. (for people with long hair,
# you could call this function multiple times on different
# rectangular regions)
def orangeHair(pic, tx, ty, w, h, color):
  for x in range(w):
    for y in range(h):
      p = getPixel(pic, tx + x, ty + y)
      if distance(getColor(p), color) 30: #you can tinker with this number depending on the shading of their hair
        #what's happening on these 3 lines is the current RGB values are being averaged with orange (255, 128, 0)
        r = (getRed(p) + 255) / 2
        g = (getGreen(p) + 128) / 2
        b = getBlue(p) / 2
        setColor(p, makeColor(r, g, b))
\end{example}

\end{itemize}
\end{ex}


\begin{ex}
\begin{example}
I
you
you
you
you
walrus
4
\end{example}
\end{ex}

\begin{ex}
D. Before even looking at any of the answer choices, you can already assume
that somewhere in the code, you should expect to see something that says
getBlue(p) 100, setBlue(p, 0), and something that traverses the entire
picture, most likely using getPixels(...). Answer D is the only one that
contains all of these. The others go over subregions of the picture, or set
the blue to something other than 0 or determine the pixel's eligibility by
using distance, all of which were not part of the criteria.
\end{ex}


\begin{ex}
\begin{example}
def checkLuminance(r, g, b):
  #you didn't actually list the "weighted averages (as below)" in the book
  lum = r * .### + g * .### + b * .### /* CHANGE ME! */
  if lum 10:
    print "That's going to be awfully dark."
  if 50 = lum =200:
    print "Looks like a good range."
  if lum > 250:
    print "That's going to be nearly white!"
\end{example}

\end{ex}


%\begin{ex}

%

%Are \recref{rec:mirrorvert} and \recref{rec:mirrorvert-shorter}

%really the same?  Look at them carefully and consider the

%\newterm{end conditions}: The points when $x$ is at the beginning

%and end of its range, for example.  It's easy in loops to be

%``off-by-one.''

%

%\end{ex}



\begin{ex}
\begin{itemize}
\item 1 - E
\item 2 - B
\item 3 - A
\item 4 - C
\item 5 - C again!

\end{ex}


\begin{ex}

4.8
A - Half scale version of original
Copying from 45 25 to 100 100
Copying from 45 27.0 to 100 101
Copying from 45 29.0 to 100 102
Copying from 45 31.0 to 100 103

B - Double scale version of the original
Copying from 45 25 to 100 100
Copying from 45 25.5 to 100 101
Copying from 45 26.0 to 100 102
Copying from 45 26.5 to 100 103

C - 50\% scaled increase of the original
Copying from 45 25 to 100 100
Copying from 45 25.666666666666667 to 100 101
Copying from 45 26.333333333333333 to 100 102
Copying from 45 27.0 to 100 103 /* Nitpick: this answer may vary depending
on the accuracy of the floating point arithmetic but will be in this
ballpark */

\end{ex}



\begin{ex}
\begin{example}
def mycollage():
  #Create our images
  image = makePicture(getMediaPath("pic.jpg"))
  bg = makePicture(getMediaPath("7inX95in.jpg"))
  #Copy the image to the top left corner
  copy(bg, image, 1, 1)
  #Make a negative of the image and copy it to the bottom right corner
  negate(image)
  copy(bg, image, 1, getHeight(bg) - getHeight(image))
  #Undo the negative transform and make the picture darker, and copy it to
the top right corner
  negate(image)
  makeDarker(image)
  copy(bg, image, getWidth(bg) - getWidth(image), 1)
  #Extreme posterize the picture to yellow and black and copy it to the
bottom right
  goJacketsPosterize(image)
  copy(bg, image, getWidth(bg) - getWidth(image), getHeight(bg) -
getHeight(image))
  #mirror the whole picture
  mirror(bg)
  #TADA!
  show(bg)
  #Here's your receipt...
  return bg

#a basic copy function that takes in a target picture, a source picture and
coordinates to copy to
def copy(canvas, picture, tx, ty):
  for x in range(getWidth(picture)):
    for y in range(getHeight(picture)):
      turnip = getPixel(picture, x + 1, y + 1)
      mushroom = getPixel(canvas, tx + x, ty + y)
      setColor(mushroom, getColor(turnip)) #copying the color of the source
pixel onto the corresponding target canvas pixel

#makes a negative
def negate(pic):
  for p in getPixels(pic):
    setRed(p, 255 - getRed(p))
    setGreen(p, 255 - getGreen(p))
    setBlue(p, 255 - getBlue(p))

#extreme posterizing with the final white replaced with yellow
def goJacketsPosterize(pic):
  for p in getPixels(pic):
    color = getColor(p)
    if distance(color, white) < distance(color, black):
      setColor(p, yellow)
    else:
      setColor(p, black)

#Mirrors an entire canvas
def mirror(pic):
  for xOffset in range(getWidth(pic) / 2):
    for y in range(1, getHeight(pic) + 1):
      pleft = getPixel(pic, xOffset + 1, y)
      pright = getPixel(pic, getWidth(pic) - xOffset, y)
      cleft = getColor(pleft)
      cright = getColor(pright)
      setColor(pleft, cright)
      setColor(pright, cleft)
\end{example}
\end{ex}

\begin{starex}
Think about how the grayscale algorithm works.  Basically, if you
know the \emph{luminance} of anything visual (e.g., a small image,
a letter), you can replace a pixel with that visual element in a
similar way to create a collage image.  Try implementing that.
You'll need 256 visual elements of increasing lightness, all of
the same size.  You'll create a collage by replacing each pixel in
the original image with one of these visual elements.

/* I will come back to this...
take in directory
grayscale all images
create list of tuples (luminance, picture object)
sort list
stretch and "fill in" list to size of 256

take in small picture and partition factor
loop through each partition
determine luminance
replace pixels with scaled picture from tuple list
*/
\end{starex}
\end{exercises}
